{"name":"Bounded Variation","tagline":"Building a Quant Finance Monte Carlo Engine in Haskell - Part 1","body":"# Introduction\r\n\r\nMy background is in quant finance, mostly writing C++, Python, and (shudder) Matlab. Over the last few months I've\r\nbeen learning Haskell, so as an excuse to learn some more Haskell, I decided to try to solve a fundamental\r\nquantitative finance problem in Haskell. Quant finance tends to love [tangled OOP](http://quantlib.org/index.shtml), so I figured a functional programming style might be a new twist on the problem.\r\n\r\nI was trying to think of a good problem to start with, and I came up with the idea of a simple (but powerful) Monte\r\nCarlo engine for Haskell. With that in mind, I started to think about architecture. I'm going to write this up in\r\na few posts, but my rough plan is:\r\n\r\n* Today's post: specification of contingent claims\r\n* Implementation of the Monte Carlo engine and underlying models\r\n* Odds and ends (implementation of simple yield curves, volatility surfaces, etc) and future plans\r\n\r\nThe target audience for this blog post is folks who know a bit of Haskell and are curious how it might apply to this particular problem.\r\n\r\n# Quick Sidebar: Quant Finance Basics\r\n\r\nIf you know even a little bit about quant finance, you can skip this. For the rest of you, a few quick pointers:\r\n\r\n1.  A contingent claim is just a payout of cash that is dependent on something happening. The simplest contingent\r\nclaim is a binary option. A binary option pays a fixed amount of cash immediately if some underlying (usually a\r\nstock) is above or below a certain amount. For instance, a binary call on XYZ stock with a fixed payout of $10 and\r\na \"strike price\" of $50 will pay $10 if XYZ is above $50 at the option's expiration.\r\n\r\n2. A Monte Carlo engine uses an underlying model to evolve values. Models specify a way of creating a growth rate\r\nand an idea of how the value will move (in some cases including a distribution). For instance, the most basic\r\nmodel (Black-Scholes), assumes that its values grow at a fixed interest rate and that they will follow a lognormal distribution. Models get very byzantine in some cases.\r\n\r\n# The ContingentClaim Type\r\n\r\nThe first thing any Monte Carlo engine needs is a way to specify your payoffs. The great Simon Peyton-Jones\r\nhimself has worked on [this very problem](http://research.microsoft.com/en-us/um/people/simonpj/Papers/financial-\r\ncontracts/contracts-icfp.htm). His solution is, of course, quite good, but it's actually too general for our\r\npurposes. There are many types of contracts that can be expressed in his system that cannot be easily priced in a\r\nMonte Carlo framework.\r\n\r\nWith that in mind, let's think about what a contingent claim really is, specifically from the standpoint of what a\r\nMonte Carlo engine needs to know about it.  \r\n\r\n1.  The MC engine needs to know what to look at. Is the option on Apple's stock or Microsoft's stock? Or maybe\r\nthe ten-year treasury rate? For my purposes, I'll refer to the value being looked at as the \"observable\".\r\n2.  The engine will need to know how to combine the different observations to turn them into a cash flow.\r\n3.  The engine will need to know when to stop evolving and check the value of the observable.\r\n\r\nThe third of these is pretty easy to represent. For this one, we'll just create a list of times when the model\r\nneeds to stop and check an observable. Easy enough.\r\n\r\nNow for 1 and 2, let's make this a little simpler. What if every time we stop the model, we simply put a structure\r\ncontaining all of the observables into a Map, keyed off of a Time? Then we can finish specifying our contingent claim with a function with this type:\r\n\r\n```haskell\r\nMap Time Observables -> CashFlow\r\n```\r\n\r\nWhere a CashFlow is just:\r\n\r\n```haskell\r\ndata CashFlow = CashFlow { cfTime :: Time , cfAmount :: Double }\r\n```\r\n\r\nFor now let's just imagine Observables is just a list of Doubles. In practice we're doing something better than that (see the bottom of this post for some details), but let's keep it simple for now.\r\n\r\nAfter some iterations on the design, I came up with the following types to represent contingent claims.\r\n\r\n```haskell\r\ndata CCProcessor = CCProcessor { \r\n    monitorTime :: Time \r\n  , payoutFunc  :: [Map Time Observables -> CashFlow]\r\n}\r\nnewtype ContingentClaim = ContingentClaim { unCC :: [CCProcessor] }\r\n```\r\nIf you can think about this from the standpoint of the Monte Carlo engine, the engine can tick through each element\r\nof the list. At each element it will evolve the simulation through until the given Time and put the Observables\r\ninto a running Map. Once this is done it will run any payoutFunc that is available (or maybe multiple ones) and determine the cash flows that need to be processed.\r\n\r\n# Monoid to the Rescue\r\n\r\nOne nifty thing about this is that it's easy to put together a bunch of different contingent claims simply by interleaving them based on the Time field.\r\n\r\n```haskell\r\n-- | Combines two contingent claims into one. \r\ncombine :: ContingentClaim a -> ContingentClaim a -> ContingentClaim a\r\ncombine (ContingentClaim x) (ContingentClaim y) = ContingentClaim $ combine' x y\r\n  where\r\n    combine' (cc1:ccs1) (cc2:ccs2)\r\n      | monitorTime cc1 == monitorTime cc2 = let\r\n            CCProcessor t mf  = cc1\r\n            CCProcessor _ mf' = cc2 in\r\n          CCProcessor t (mf++mf') : combine' ccs1 ccs2\r\n      | monitorTime cc1 > monitorTime cc2 = cc2 : combine' (cc1:ccs1) ccs2\r\n      | otherwise = cc1 : combine' ccs1 (cc2:ccs2)\r\n    combine' cs1 cs2 = cs1 ++ cs2\r\n```\r\n\r\nBut wait a sec, this is neat:\r\n\r\n```haskell\r\ninstance Monoid ContingentClaim where \r\n  mempty = ContingentClaim [] \r\n  mappend = combine\r\n```\r\nSo now I can very easily compose a bunch of different options together. That seems handy.\r\n\r\n# Monads Enter the Picture\r\n\r\nNow let's think about what a few simple options would look like in this framework.  A binary call option with a payout of 50 with a strike of 100 on the 0th observable, paying out at time 1, would look like this:\r\n\r\n```haskell\r\nbinCall = ContingentClaim [1.0, [\\m -> if m ! 1.0 !! 0 > 100 then 50 else 0]]\r\n```\r\nOkay, that's a bit ugly. Now imagine if I want a payout that averages the observable's price over ten different\r\ntimes? Trust me, I've tried, it isn't pretty.\r\n\r\nSo what we need is a way to build up a ContingentClaim in a nice composable way. Now the answer to every\r\nquestion in Haskell is \"Make a monad!\", and this is no different. So what I did was combined two monads, the\r\nReader and Writer monad. The Reader monad (which is really just the function monad) allows me to build up my\r\npayout function in a pretty nice and composable way. Meanwhile the Writer monad keeps track of the times I'm\r\nchecking the observable.\r\n\r\n```haskell \r\ntype CCBuilder w r a = WriterT w (Reader r) a\r\n```\r\n\r\nWe'll also need something to pull our completed ContingentClaim out of the monad. The details of the implementation are beyond the scope of this (and tedious anyway), so just make note of the type:\r\n\r\n```haskell \r\nspecify :: CCBuilder ContingentClaim (Map Time Observables) CashFlow \r\n        -> ContingentClaim\r\n```\r\n\r\nNow let's make a function that checks an observable's value at a certain time. We'll call it monitor, and it'll check the 0th observable.\r\n\r\n```haskell \r\nmonitor :: Time -> CCBuilder ContingentClaim (Map Observables Double) Double \r\nmonitor t = do \r\n  tell $ ContingentClaim [CCProcessor t []] --adds to the list of Times\r\n  m <- ask  --grabs the Map of values\r\n  return $ (m ! t) !! 0 --Yes, I know how ugly this is.\r\n```\r\n\r\nThe details of the Reader and Writer monad are beyond the scope of this post, but suffice it to say that this adds to the running total of times to check the observable (tell), and while getting the value out of the map to use in the Reader monad.\r\n\r\nNow we have all we need to build composable contingent claims. A few examples:\r\n\r\n```haskell \r\n\r\nbinCall strike t payout = specify $ do \r\n  x <- monitor t \r\n  let amt = if x > strike then payout else 0 \r\n  return (CashFlow t amt)\r\n\r\nvanillaCall strike t = specify $ do \r\n  x <- monitor t \r\n  let amt = max (x - strike) 0 \r\n  return (CashFlow t amt)\r\n\r\n--Calculates the average price on a series of times. \r\naveragePrice priceTimes t = specify $ \r\n  do x <- mapM monitor priceTimes \r\n  let val = sum x / fromIntegral (length x) \r\n  return $ CashFlow t val\r\n\r\n--We can even do insane things \r\nbizarre = specify $ do\r\n  x <- monitor 0.5 \r\n  y <- monitor 1.0 \r\n  z <- monitor 2.0 \r\n  let t = if sin x > 0 then 7.0 else 2.0 --why would we do this??? \r\n  return $ CashFlow t (cos (y + z))\r\n\r\n--let's put a binary option together with a vanilla option! \r\nportfolio = binCall 100 1 50 <> vanillaCall 100 1\r\n```\r\n\r\nAdditionally the library contains some helpful functions like multiplier, which scales up a ContingentClaim payout by a constant factor. And of course I can make a function `short = multiplier (-1)`. So a call spread could look like this:\r\n\r\n```haskell\r\ncallSpread lowStrike highStrike t = vanillaCall lowStrike t <> short (vanillaCall highStrike t)\r\n```\r\nNeat!\r\n\r\n# Wrapping Up a Loose End - The Observables Type\r\n\r\nI mentioned earlier that the Observables type is a bit more sophisticated than I was letting on. The issue is that\r\nright now I can do this:\r\n\r\n```haskell \r\nunsafeMonitor t = do \r\n  m <- ask \r\n  return (m ! t !! 3)\r\n```\r\n\r\nBut what if 3 is out of bounds? With that in mind, I created types that represent fixed length vectors. For instance:\r\n\r\n```haskell\r\n--I'm leaving out the UNPACK pragma and strictness annotations, \r\n--but you get the idea. \r\ndata Observables1 = Observables1 Double \r\ndata Observables2 = Observables2 Double Double \r\n-- ...\r\n\r\nclass Obs1 a where \r\n  obs1 :: a -> Double\r\nclass Obs2 a where \r\n  obs2 :: a -> Double\r\n\r\ninstance Obs1 Observables1 where \r\n  obs1 (Observables1 x) = x\r\ninstance Obs1 Observables2 where \r\n  obs1 (Observables2 x _) = x\r\ninstance Obs2 Observables2 where \r\n  obs2 (Observables2 _ x) = x\r\n-- ...\r\n``` \r\n\r\nEnough of that, you get the idea. Now a quick rewrite of the unsafeMonitor function:\r\n\r\n```haskell\r\nmonitor t = do\r\n  tell $ ContingentClaim [CCProcessor t []]\r\n  m <- ask \r\n  return (obs4 $ m ! t)\r\n```\r\n\r\nOne last change:\r\n\r\n```haskell\r\ndata CCProcessor a = CCProcessor  {\r\n    monitorTime      :: Time\r\n  , payoutFunc       :: [M.Map Time a -> CashFlow]\r\n}\r\n\r\nnewtype ContingentClaim a = ContingentClaim { unCC :: [CCProcessor a] }\r\n\r\n--we'll need RankNTypes\r\n\r\n--contingent claims with one observable.\r\ntype ContingentClaim1 = forall a . Obs1 a => ContingentClaim a\r\n--contingent claims with two observables.\r\ntype ContingentClaim2 = forall a . Obs2 a => ContingentClaim a\r\n-- ...\r\n```\r\n\r\nAnd the type checker will now ensure that you're not accessing something that isn't being modeled. More on this\r\nwhen we get into the model implementation details.\r\n\r\n# Conclusion\r\n\r\nYou almost certainly haven't had as much fun reading this as I had writing the library. Haskell completely changes\r\nthe way you solve problems, and while the abstractions are unfamiliar at first, they're remarkably powerful. It's\r\nstill very much pre-pre-alpha but under heavy development.\r\n\r\nIn the mean time, check out the package on [GitHub](https://github.com/boundedvariation/quantfin) or [Hackage](https://hackage.haskell.org/package/quantfin-0.2.0.0).\r\n\r\nNext time we'll cover a little bit about how we put together the engine itself and implemented models.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}